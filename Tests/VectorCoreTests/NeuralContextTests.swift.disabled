// VectorCore: Neural Engine Context Tests
//
// Tests for the Neural Engine execution context placeholder
//

import XCTest
@testable import VectorCore
#if canImport(CoreML)
import CoreML
#endif

@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
final class NeuralContextTests: XCTestCase {
    
    // MARK: - Device Availability
    
    func testNeuralEngineAvailability() {
        let neuralDevice = ComputeDevice.neural
        
        // Neural Engine availability depends on hardware
        if NeuralContext.isAvailable {
            XCTAssertTrue(neuralDevice.isAvailable)
        } else {
            XCTAssertFalse(neuralDevice.isAvailable)
        }
    }
    
    func testNeuralContextCreation() {
        // Try to create Neural context
        let context = NeuralContext.createIfAvailable()
        
        if NeuralContext.isAvailable {
            XCTAssertNotNil(context)
            XCTAssertEqual(context?.device, .neural)
        } else {
            XCTAssertNil(context)
        }
    }
    
    // MARK: - Context Properties
    
    func testNeuralContextProperties() throws {
        guard let context = NeuralContext.createIfAvailable() else {
            throw XCTSkip("Neural Engine not available on this device")
        }
        
        // Verify properties
        XCTAssertEqual(context.device, .neural)
        XCTAssertEqual(context.maxThreadCount, 1)
        XCTAssertEqual(context.preferredChunkSize, 256)
        
        // Power efficiency should be high
        XCTAssertEqual(context.powerEfficiency, 10.0)
    }
    
    // MARK: - Execution Tests
    
    func testNeuralContextExecution() async throws {
        guard let context = NeuralContext.createIfAvailable() else {
            throw XCTSkip("Neural Engine not available on this device")
        }
        
        // Test basic execution (currently falls back to CPU)
        let result = try await context.execute {
            return "Neural execution test"
        }
        
        XCTAssertEqual(result, "Neural execution test")
    }
    
    func testNeuralContextComputation() async throws {
        guard let context = NeuralContext.createIfAvailable() else {
            throw XCTSkip("Neural Engine not available on this device")
        }
        
        // Test computation
        let result = try await context.execute {
            // Simulate vector operation
            let vector = Array(repeating: 1.0, count: 256)
            return vector.reduce(0, +)
        }
        
        XCTAssertEqual(result, 256.0)
    }
    
    // MARK: - Acceleration Status
    
    func testNeuralAccelerationStatus() throws {
        guard let context = NeuralContext.createIfAvailable() else {
            throw XCTSkip("Neural Engine not available on this device")
        }
        
        // Currently no operations are Neural-accelerated
        XCTAssertFalse(context.isNeuralAccelerated(operation: .distanceComputation))
        XCTAssertFalse(context.isNeuralAccelerated(operation: .matrixMultiplication))
        XCTAssertFalse(context.isNeuralAccelerated(operation: .vectorNormalization))
        XCTAssertFalse(context.isNeuralAccelerated(operation: .batchedOperations))
    }
    
    // MARK: - Device Integration
    
    func testDeviceCreateContext() {
        let neuralDevice = ComputeDevice.neural
        
        if neuralDevice.isAvailable {
            let context = neuralDevice.createContext()
            
            if NeuralContext.isAvailable {
                XCTAssertNotNil(context)
                XCTAssertEqual(context?.device, .neural)
            } else {
                XCTAssertNil(context)
            }
        }
    }
    
    func testDeviceProperties() {
        let device = ComputeDevice.neural
        
        // Check properties
        XCTAssertTrue(device.isAccelerated)
        XCTAssertEqual(device.description, "Neural Engine")
        XCTAssertEqual(device.requiredAlignment, 64)
        XCTAssertEqual(device.minimumEfficientSize, 1000)
    }
    
    // MARK: - Neural Operation Types
    
    func testNeuralOperationMinimumBatchSizes() {
        // Test minimum batch sizes for different operations
        XCTAssertEqual(NeuralOperation.vectorAddition.minimumBatchSize, 128)
        XCTAssertEqual(NeuralOperation.vectorMultiplication.minimumBatchSize, 128)
        XCTAssertEqual(NeuralOperation.vectorNormalization.minimumBatchSize, 256)
        XCTAssertEqual(NeuralOperation.batchEuclideanDistance.minimumBatchSize, 64)
        XCTAssertEqual(NeuralOperation.batchCosineDistance.minimumBatchSize, 64)
        XCTAssertEqual(NeuralOperation.matrixMultiplication.minimumBatchSize, 32)
        XCTAssertEqual(NeuralOperation.matrixFactorization.minimumBatchSize, 16)
        XCTAssertEqual(NeuralOperation.embeddingLookup.minimumBatchSize, 8)
        XCTAssertEqual(NeuralOperation.attentionMechanism.minimumBatchSize, 8)
    }
    
    // MARK: - Configuration
    
    func testNeuralContextConfiguration() throws {
        #if canImport(CoreML)
        // Test with custom configuration
        let config = MLModelConfiguration()
        config.computeUnits = .all
        
        do {
            let context = try NeuralContext(configuration: config)
            XCTAssertNotNil(context)
        } catch {
            // Neural Engine might not be available
            XCTAssertTrue(error is VectorError)
        }
        #else
        throw XCTSkip("CoreML not available")
        #endif
    }
    
    // MARK: - Most Capable Device
    
    func testMostCapableDevice() {
        let mostCapable = ComputeDevice.mostCapable
        
        // Should return the most capable available device
        let available = ComputeDevice.availableDevices
        
        if available.contains(.neural) {
            XCTAssertEqual(mostCapable, .neural)
        } else if available.contains(where: { if case .gpu = $0 { return true } else { return false } }) {
            if case .gpu = mostCapable {
                // Success - it's a GPU
            } else {
                XCTFail("Expected GPU but got \(mostCapable)")
            }
        } else {
            XCTAssertEqual(mostCapable, .cpu)
        }
    }
}