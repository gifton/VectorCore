// VectorCore: Alignment Tests
//
// Tests to verify proper memory alignment for SIMD operations
//

import XCTest
@testable import VectorCore

final class AlignmentTests: XCTestCase {
    
    // MARK: - Storage Alignment Tests
    
    func testStorage32Alignment() {
        let storage = Storage32(repeating: 1.0)
        
        storage.withUnsafeBufferPointer { buffer in
            guard let baseAddress = buffer.baseAddress else {
                XCTFail("Buffer has no base address")
                return
            }
            
            let alignment = Int(bitPattern: baseAddress) % AlignedMemory.minimumAlignment
            XCTAssertEqual(alignment, 0, "Storage32 is not properly aligned")
        }
    }
    
    func testStorage64Alignment() {
        let storage = Storage64(repeating: 1.0)
        
        storage.withUnsafeBufferPointer { buffer in
            guard let baseAddress = buffer.baseAddress else {
                XCTFail("Buffer has no base address")
                return
            }
            
            let alignment = Int(bitPattern: baseAddress) % AlignedMemory.minimumAlignment
            XCTAssertEqual(alignment, 0, "Storage64 is not properly aligned")
        }
    }
    
    func testMediumVectorStorageAlignment() {
        let sizes = [65, 128, 256, 512]
        
        for size in sizes {
            let storage = MediumVectorStorage(count: size, repeating: 1.0)
            
            storage.withUnsafeBufferPointer { buffer in
                guard let baseAddress = buffer.baseAddress else {
                    XCTFail("Buffer has no base address for size \(size)")
                    return
                }
                
                let alignment = Int(bitPattern: baseAddress) % AlignedMemory.optimalAlignment
                XCTAssertEqual(alignment, 0, "MediumVectorStorage size \(size) is not properly aligned")
            }
        }
    }
    
    func testLargeVectorStorageAlignment() {
        let sizes = [513, 768, 1024, 1536, 3072, 4096]
        
        for size in sizes {
            let storage = LargeVectorStorage(count: size, repeating: 1.0)
            
            storage.withUnsafeBufferPointer { buffer in
                guard let baseAddress = buffer.baseAddress else {
                    XCTFail("Buffer has no base address for size \(size)")
                    return
                }
                
                let alignment = Int(bitPattern: baseAddress) % AlignedMemory.minimumAlignment
                XCTAssertEqual(alignment, 0, "LargeVectorStorage size \(size) is not properly aligned")
            }
        }
    }
    
    func testAlignedDynamicArrayStorageAlignment() {
        let sizes = [1, 64, 128, 512, 1024, 2048]
        let alignments = [16, 32, 64]
        
        for size in sizes {
            for alignment in alignments {
                let storage = AlignedDynamicArrayStorage(dimension: size, alignment: alignment)
                
                storage.withUnsafeBufferPointer { buffer in
                    guard let baseAddress = buffer.baseAddress else {
                        XCTFail("Buffer has no base address for size \(size), alignment \(alignment)")
                        return
                    }
                    
                    let actualAlignment = Int(bitPattern: baseAddress) % alignment
                    XCTAssertEqual(actualAlignment, 0, "AlignedDynamicArrayStorage size \(size) is not aligned to \(alignment)")
                }
                
                // Verify the storage reports its alignment correctly
                XCTAssertEqual(storage.guaranteedAlignment, alignment)
                XCTAssertTrue(storage.verifyAlignment())
            }
        }
    }
    
    func testCOWDynamicStorageAlignment() {
        let storage = COWDynamicStorage(dimension: 1024)
        
        storage.withUnsafeBufferPointer { buffer in
            guard let baseAddress = buffer.baseAddress else {
                XCTFail("Buffer has no base address")
                return
            }
            
            let alignment = Int(bitPattern: baseAddress) % AlignedMemory.minimumAlignment
            XCTAssertEqual(alignment, 0, "COWDynamicStorage is not properly aligned")
        }
        
        // Test COW preserves alignment
        var storage2 = storage
        storage2[0] = 42.0  // Trigger COW
        
        storage2.withUnsafeBufferPointer { buffer in
            guard let baseAddress = buffer.baseAddress else {
                XCTFail("Buffer has no base address after COW")
                return
            }
            
            let alignment = Int(bitPattern: baseAddress) % AlignedMemory.minimumAlignment
            XCTAssertEqual(alignment, 0, "COWDynamicStorage is not properly aligned after COW")
        }
    }
    
    // MARK: - Vector Type Alignment Tests
    
    func testStaticVectorAlignment() {
        // Test small dimension vectors that use SmallVectorStorage
        let vec32 = Vector<Dim32>(repeating: 1.0)
        let vec64 = Vector<Dim64>(repeating: 1.0)
        
        // These use SmallVectorStorage internally
        vec32.storage.withUnsafeBufferPointer { buffer in
            guard let baseAddress = buffer.baseAddress else { return }
            let alignment = Int(bitPattern: baseAddress) % AlignedMemory.minimumAlignment
            XCTAssertEqual(alignment, 0, "Vector<Dim32> is not properly aligned")
        }
        
        vec64.storage.withUnsafeBufferPointer { buffer in
            guard let baseAddress = buffer.baseAddress else { return }
            let alignment = Int(bitPattern: baseAddress) % AlignedMemory.minimumAlignment
            XCTAssertEqual(alignment, 0, "Vector<Dim64> is not properly aligned")
        }
    }
    
    func testDynamicVectorAlignment() {
        let sizes = [16, 64, 128, 512, 1024]
        
        for size in sizes {
            let vec = DynamicVector(dimension: size, repeating: 1.0)
            
            // We can't access storage directly, but we can verify through operations
            // that require alignment (like dot product)
            let vec2 = DynamicVector(dimension: size, repeating: 2.0)
            
            // This will crash if not properly aligned on some architectures
            let dotProduct = vec.dotProduct(vec2)
            XCTAssertEqual(dotProduct, Float(size) * 2.0, accuracy: 1e-5,
                          "DynamicVector operations suggest misalignment for size \(size)")
        }
    }
    
    func testConsolidatedVectorAlignment() {
        // Test all vector types through unified interface
        let vec128 = Vector128(repeating: 1.0)
        let vec256 = Vector256(repeating: 1.0)
        let vec512 = Vector512(repeating: 1.0)
        let vec768 = Vector768(repeating: 1.0)
        let vec1536 = Vector1536(repeating: 1.0)
        let vec3072 = Vector3072(repeating: 1.0)
        
        // All should have proper alignment
        vec128.storage.withUnsafeBufferPointer { buffer in
            guard let baseAddress = buffer.baseAddress else { return }
            let alignment = Int(bitPattern: baseAddress) % AlignedMemory.minimumAlignment
            XCTAssertEqual(alignment, 0, "Vector128 is not properly aligned")
        }
        
        vec256.storage.withUnsafeBufferPointer { buffer in
            guard let baseAddress = buffer.baseAddress else { return }
            let alignment = Int(bitPattern: baseAddress) % AlignedMemory.minimumAlignment
            XCTAssertEqual(alignment, 0, "Vector256 is not properly aligned")
        }
        
        vec512.storage.withUnsafeBufferPointer { buffer in
            guard let baseAddress = buffer.baseAddress else { return }
            let alignment = Int(bitPattern: baseAddress) % AlignedMemory.minimumAlignment
            XCTAssertEqual(alignment, 0, "Vector512 is not properly aligned")
        }
        
        vec768.storage.withUnsafeBufferPointer { buffer in
            guard let baseAddress = buffer.baseAddress else { return }
            let alignment = Int(bitPattern: baseAddress) % AlignedMemory.minimumAlignment
            XCTAssertEqual(alignment, 0, "Vector768 is not properly aligned")
        }
        
        vec1536.storage.withUnsafeBufferPointer { buffer in
            guard let baseAddress = buffer.baseAddress else { return }
            let alignment = Int(bitPattern: baseAddress) % AlignedMemory.minimumAlignment
            XCTAssertEqual(alignment, 0, "Vector1536 is not properly aligned")
        }
        
        vec3072.storage.withUnsafeBufferPointer { buffer in
            guard let baseAddress = buffer.baseAddress else { return }
            let alignment = Int(bitPattern: baseAddress) % AlignedMemory.minimumAlignment
            XCTAssertEqual(alignment, 0, "Vector3072 is not properly aligned")
        }
    }
    
    // MARK: - Alignment Preservation Tests
    
    func testAlignmentAfterOperations() {
        let vec1 = Vector256(repeating: 1.0)
        let vec2 = Vector256(repeating: 2.0)
        
        // Test that operations preserve alignment
        let sum = vec1 + vec2
        let diff = vec1 - vec2
        let scaled = vec1 * 3.0
        let normalized = vec1.normalized()
        
        sum.storage.withUnsafeBufferPointer { buffer in
            guard let baseAddress = buffer.baseAddress else { return }
            let alignment = Int(bitPattern: baseAddress) % AlignedMemory.minimumAlignment
            XCTAssertEqual(alignment, 0, "Sum result is not properly aligned")
        }
        
        diff.storage.withUnsafeBufferPointer { buffer in
            guard let baseAddress = buffer.baseAddress else { return }
            let alignment = Int(bitPattern: baseAddress) % AlignedMemory.minimumAlignment
            XCTAssertEqual(alignment, 0, "Difference result is not properly aligned")
        }
        
        scaled.storage.withUnsafeBufferPointer { buffer in
            guard let baseAddress = buffer.baseAddress else { return }
            let alignment = Int(bitPattern: baseAddress) % AlignedMemory.minimumAlignment
            XCTAssertEqual(alignment, 0, "Scaled result is not properly aligned")
        }
        
        normalized.storage.withUnsafeBufferPointer { buffer in
            guard let baseAddress = buffer.baseAddress else { return }
            let alignment = Int(bitPattern: baseAddress) % AlignedMemory.minimumAlignment
            XCTAssertEqual(alignment, 0, "Normalized result is not properly aligned")
        }
    }
    
    // MARK: - Performance Impact Tests
    
    func testAlignedVsUnalignedPerformance() {
        let size = 1024
        let iterations = 10000
        
        // Create aligned storage
        let aligned1 = AlignedDynamicArrayStorage(dimension: size, repeating: 1.0, alignment: 64)
        let aligned2 = AlignedDynamicArrayStorage(dimension: size, repeating: 2.0, alignment: 64)
        
        // Measure aligned performance
        measure {
            for _ in 0..<iterations {
                _ = aligned1.dotProduct(aligned2)
            }
        }
        
        // Note: We can't easily create unaligned storage in Swift,
        // but the test verifies that our storage is properly aligned
        XCTAssertTrue(aligned1.verifyAlignment())
        XCTAssertTrue(aligned2.verifyAlignment())
    }
}