// VectorCore: Convenience Initializers
//
// Additional initializers for common vector creation patterns
//

import Foundation

// MARK: - Vector Convenience Initializers

public extension Vector where D.Storage: VectorStorageOperations {

    // MARK: Basis Vectors

    /// Create a basis vector (unit vector along a specific axis)
    /// - Parameter axis: The axis index (0-based)
    /// - Returns: A vector with 1.0 at the specified axis and 0.0 elsewhere
    @inlinable
    static func basis(axis: Int) -> Vector<D> {
        precondition(axis >= 0 && axis < D.value, "Axis index out of bounds")
        var result = Vector()
        result[axis] = 1.0
        return result
    }

    /// Throwing variant of basis(axis:)
    /// - Throws: VectorError.indexOutOfBounds if axis is invalid
    @inlinable
    static func basisThrowing(axis: Int) throws -> Vector<D> {
        try Validation.requireValidIndex(axis, dimension: D.value)
        var result = Vector()
        result[axis] = 1.0
        return result
    }

    /// Safely create a basis vector (unit vector along a specific axis)
    /// - Parameter axis: The axis index (0-based)
    /// - Returns: A vector with 1.0 at the specified axis and 0.0 elsewhere, or nil if axis is out of bounds
    @inlinable
    static func basis(safe axis: Int) -> Vector<D>? {
        guard axis >= 0 && axis < D.value else { return nil }
        var result = Vector()
        result[axis] = 1.0
        return result
    }

    /// Create the standard basis vector e_i
    /// - Parameter i: The basis index (0-based)
    /// - Returns: The i-th standard basis vector
    @inlinable
    static func e(_ i: Int) -> Vector<D> {
        basis(axis: i)
    }

    /// Throwing variant of e(_:)
    /// - Throws: VectorError.indexOutOfBounds if i is invalid
    @inlinable
    static func eThrowing(_ i: Int) throws -> Vector<D> {
        try basisThrowing(axis: i)
    }

    // MARK: Sequential Initializers

    /// Create a vector with linearly spaced values
    /// - Parameters:
    ///   - from: Starting value
    ///   - to: Ending value (inclusive)
    /// - Returns: Vector with values linearly interpolated from start to end
    @inlinable
    static func linspace(from: Float, to: Float) -> Vector<D> {
        let n = D.value
        guard n > 1 else {
            return Vector(repeating: from)
        }

        let step = (to - from) / Float(n - 1)
        var result = Vector()

        for i in 0..<n {
            result[i] = from + Float(i) * step
        }

        return result
    }

    /// Create a vector with values from 0 to n-1
    /// - Returns: Vector with sequential integer values cast to Float
    @inlinable
    static func range() -> Vector<D> {
        var result = Vector()
        for i in 0..<D.value {
            result[i] = Float(i)
        }
        return result
    }

    /// Create a vector with values from start to start+n-1
    /// - Parameter start: Starting value
    /// - Returns: Vector with sequential values
    @inlinable
    static func range(from start: Float) -> Vector<D> {
        var result = Vector()
        for i in 0..<D.value {
            result[i] = start + Float(i)
        }
        return result
    }

    // MARK: Function-based Initializers

    /// Create a vector by applying a function to each index
    /// - Parameter generator: Function that takes an index and returns a value
    /// - Returns: Vector with values generated by the function
    @inlinable
    static func generate(_ generator: (Int) -> Float) -> Vector<D> {
        var result = Vector()
        for i in 0..<D.value {
            result[i] = generator(i)
        }
        return result
    }

    /// Create a vector by mapping indices through a closure
    /// - Parameter transform: Closure that transforms index to value
    /// - Returns: Vector with transformed values
    @inlinable
    init(indexMap transform: (Int) -> Float) {
        self = Vector.generate(transform)
    }

    // MARK: Mathematical Sequences

    /// Create a vector with geometric sequence
    /// - Parameters:
    ///   - initial: First value
    ///   - ratio: Common ratio between consecutive elements
    /// - Returns: Vector with geometric progression
    @inlinable
    static func geometric(initial: Float, ratio: Float) -> Vector<D> {
        var result = Vector()
        var current = initial

        for i in 0..<D.value {
            result[i] = current
            current *= ratio
        }

        return result
    }

    /// Create a vector with powers of a base
    /// - Parameter base: The base value
    /// - Returns: Vector with values [1, base, base², base³, ...]
    @inlinable
    static func powers(of base: Float) -> Vector<D> {
        geometric(initial: 1.0, ratio: base)
    }

    /// Create a vector with alternating signs
    /// - Parameter magnitude: The magnitude of each element
    /// - Returns: Vector with pattern [magnitude, -magnitude, magnitude, ...]
    @inlinable
    static func alternating(magnitude: Float = 1.0) -> Vector<D> {
        Vector { i in
            i % 2 == 0 ? magnitude : -magnitude
        }
    }

    // MARK: Special Patterns

    /// Create a one-hot vector
    /// - Parameter index: The index to set to 1.0
    /// - Returns: Vector with single non-zero element
    @inlinable
    static func oneHot(at index: Int) -> Vector<D> {
        basis(axis: index)
    }

    /// Throwing variant of oneHot(at:)
    /// - Throws: VectorError.indexOutOfBounds if index is invalid
    @inlinable
    static func oneHotThrowing(at index: Int) throws -> Vector<D> {
        try basisThrowing(axis: index)
    }

    /// Create a vector with a repeating pattern
    /// - Parameter pattern: Array defining the pattern to repeat
    /// - Returns: Vector with repeated pattern
    @inlinable
    static func repeatingPattern(_ pattern: [Float]) -> Vector<D> {
        precondition(!pattern.isEmpty, "Pattern cannot be empty")

        return Vector { i in
            pattern[i % pattern.count]
        }
    }

    /// Throwing variant of repeatingPattern(_:)
    /// - Throws: VectorError.invalidData if pattern is empty
    @inlinable
    static func repeatingPatternThrowing(_ pattern: [Float]) throws -> Vector<D> {
        guard !pattern.isEmpty else { throw VectorError.invalidData("Pattern cannot be empty") }
        return Vector { i in
            pattern[i % pattern.count]
        }
    }

    /// Safely create a vector with a repeating pattern
    /// - Parameter pattern: Array defining the pattern to repeat
    /// - Returns: Vector with repeated pattern, or nil if pattern is empty
    @inlinable
    static func repeatingPattern(safe pattern: [Float]) -> Vector<D>? {
        guard !pattern.isEmpty else { return nil }

        return Vector { i in
            pattern[i % pattern.count]
        }
    }

    /// Create a vector with values in a specific range set to a value
    /// - Parameters:
    ///   - value: The value to set
    ///   - indices: The indices to set
    /// - Returns: Vector with specified indices set to value, others zero
    @inlinable
    static func sparse(value: Float, at indices: Set<Int>) -> Vector<D> {
        var result = Vector()
        for index in indices where index >= 0 && index < D.value {
            result[index] = value
        }
        return result
    }
}

// MARK: - DynamicVector Convenience Initializers

public extension DynamicVector {

    // MARK: Basis Vectors

    /// Create a basis vector
    /// - Parameters:
    ///   - dimension: Vector dimension
    ///   - axis: The axis index (0-based)
    /// - Returns: A vector with 1.0 at the specified axis and 0.0 elsewhere
    static func basis(dimension: Int, axis: Int) -> DynamicVector {
        precondition(axis >= 0 && axis < dimension, "Axis index out of bounds")
        var result = DynamicVector(dimension: dimension)
        result[axis] = 1.0
        return result
    }

    /// Throwing variant of basis(dimension:axis:)
    /// - Throws: VectorError.invalidDimension if dimension <= 0
    ///           VectorError.indexOutOfBounds if axis is invalid
    static func basisThrowing(dimension: Int, axis: Int) throws -> DynamicVector {
        try Validation.requireValidDimension(dimension)
        try Validation.requireValidIndex(axis, dimension: dimension)
        var result = DynamicVector(dimension: dimension)
        result[axis] = 1.0
        return result
    }

    // MARK: Sequential Initializers

    /// Create a vector with linearly spaced values
    /// - Parameters:
    ///   - dimension: Vector dimension
    ///   - from: Starting value
    ///   - to: Ending value (inclusive)
    /// - Returns: Vector with values linearly interpolated from start to end
    static func linspace(dimension: Int, from: Float, to: Float) -> DynamicVector {
        guard dimension > 1 else {
            return DynamicVector(dimension: dimension, repeating: from)
        }

        let step = (to - from) / Float(dimension - 1)
        let values = (0..<dimension).map { i in
            from + Float(i) * step
        }

        return DynamicVector(values)
    }

    /// Create a vector with sequential values
    /// - Parameters:
    ///   - dimension: Vector dimension
    ///   - start: Starting value (default 0)
    /// - Returns: Vector with sequential values
    static func range(dimension: Int, from start: Float = 0) -> DynamicVector {
        let values = (0..<dimension).map { i in
            start + Float(i)
        }
        return DynamicVector(values)
    }

    // MARK: Function-based Initializers

    /// Create a vector by applying a function to each index
    /// - Parameters:
    ///   - dimension: Vector dimension
    ///   - generator: Function that takes an index and returns a value
    /// - Returns: Vector with values generated by the function
    static func generate(dimension: Int, _ generator: (Int) -> Float) -> DynamicVector {
        let values = (0..<dimension).map(generator)
        return DynamicVector(values)
    }

    /// Initialize by mapping indices through a closure
    /// - Parameters:
    ///   - dimension: Vector dimension
    ///   - transform: Closure that transforms index to value
    init(dimension: Int, indexMap transform: (Int) -> Float) {
        let values = (0..<dimension).map(transform)
        self.init(values)
    }

    // MARK: Mathematical Sequences

    /// Create a vector with geometric sequence
    /// - Parameters:
    ///   - dimension: Vector dimension
    ///   - initial: First value
    ///   - ratio: Common ratio between consecutive elements
    /// - Returns: Vector with geometric progression
    static func geometric(dimension: Int, initial: Float, ratio: Float) -> DynamicVector {
        var values = [Float](repeating: 0, count: dimension)
        var current = initial

        for i in 0..<dimension {
            values[i] = current
            current *= ratio
        }

        return DynamicVector(values)
    }

    /// Create a vector with alternating signs
    /// - Parameters:
    ///   - dimension: Vector dimension
    ///   - magnitude: The magnitude of each element
    /// - Returns: Vector with alternating positive/negative values
    static func alternating(dimension: Int, magnitude: Float = 1.0) -> DynamicVector {
        DynamicVector(dimension: dimension) { i in
            i % 2 == 0 ? magnitude : -magnitude
        }
    }
}

// MARK: - Type Aliases for Common Patterns

public extension Vector where D.Storage: VectorStorageOperations {
    /// Standard unit vector along X axis (first component)
    static var unitX: Vector<D> { basis(axis: 0) }

    /// Standard unit vector along Y axis (second component)
    static var unitY: Vector<D> { D.value > 1 ? basis(axis: 1) : zero }

    /// Standard unit vector along Z axis (third component)
    static var unitZ: Vector<D> { D.value > 2 ? basis(axis: 2) : zero }
}
